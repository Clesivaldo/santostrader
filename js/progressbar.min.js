! function (a) {if ("objeto" == tipo de exportação && "indefinido"! = tipo de módulo) module.exports = a (); caso contrário, se ("função" = tipo de definição && define.amd) define ([], um ); else {var b; b = "undefined"! = typeof window? window: "undefined"! = typeof global? global: "undefined"! = typeof self? self: this, b.ProgressBar = a ()}} (função () {var a; função de retorno () {função a (b, c, d) {função e (g, h) {if (! c [g]) {if (! b [g]) {var i = "function" == typeof requer && require; if (! h && i) retorna i (g,! 0); if (f) retorna f (g,! 0); var j = new Erro ("Não é possível encontrar o módulo '" + g + "'"); throw j.code = "MODULE_NOT_FOUND", j} var k = c [g] = {exporta: {}}; b [g] [0] .call (k.exports, função (a) {return e (b [g] [1] [a] || a)}, k, k.exporta, a, b, c, d)} retorna c [g] .exports} para a função (var f = " "== typeof exige &&exigir, g = 0; g <comprimento.d; g ++) e (d [g]); retornar e} retornar a} () ({1: [function (b, c, d) {! function (b, e ) {"object" == typeof d && "object" == typeof c? c.exports = e (): "function" == typeof a && a.amd? a ("shifty", [], e): "object" == tipo de d? d.shifty = e (): b.shifty = e ()} (janela, função () {função de retorno (a) {função b (d) {se (c [d]) retornar c [ d] .exports; var e = c [d] = {i: d, l:! 1, exporta: {}}; retorna uma [d] .call (e.exports, e, e.exports, b), el =! 0, e.exporta} var c = {}; retorna bm = a, bc = c, bd = função (a, c, d) {bo (a, c) || ​​Object.defineProperty (a, c , {enumerável:! 0, get: d})}, br = function (a) {"undefined"! = tipo de Symbol && Symbol.toStringTag && Object.defineProperty (a, Symbol.toStringTag, {value: "Module"}), Object. defineProperty (a, "__ esModule", {valor:! 0})}, bt = função (a, c) {if (1 & c && (a = b (a)), 8 &c) retorna a; if (4 & c && "objeto" == tipo de a && a && a .__ esModule) retorna a; var d = Object.create (null); if (br (d), Object.defineProperty (d, "default", {enumerable :! 0, valor: a}), 2 & c && "string"! = Tipo de a) para (var e a) bd (d, e, função (b) {retorna a [b]}. Bind (null, e) ); return d}, bn = function (a) {var c = a && a .__ esModule? function () {return a.default}: function () {return a}; return bd (c, "a", c), c}, bo = function (a, b) {retorna Object.prototype.hasOwnProperty.call (a, b)}, bp = "", b (bs = 3)} ([function (a, b, c) { "use strict"; (function (a) {function d (a, b) {for (var c = 0; c <comprimento.b; c ++) {var d = b [c]; d.enumerable = d.enumerable ||! 1, d.configurable =! 0, "value" em d && (d.writable =! 0), Object.defineProperty (a, d.key, d)}} função e (a) {return (e = "função" == tipo de símbolo &&"symbol" == typeof Symbol.iterator? function (a) {return typeof a}: function (a) {return a && "function" == typeof Symbol && a.constructor === Symbol && a! == Symbol.prototype? "symbol" : typeof a}) (a)} function f (a, b) {var c = Object.keys (a); if (Object.getOwnPropertySymbols) {var d = Object.getOwnPropertySymbols (a); b && (d = d. filter (function (b) {return Object.getOwnPropertyDescriptor (a, b) .enumerable})), c.push.apply (c, d)} return c} função g (a) {for (var b = 1; b <argumentos.length; b ++) {var c = null! = argumentos [b]? argumentos [b]: {}; b% 2? f (Objeto (c) ,! 0) .forEach (função (b) {h (a, b, c [b])}): Object.getOwnPropertyDescriptors? Object.defineProperties (a, Object.getOwnPropertyDescriptors (c)): f (Object (c)). forEach (function (b) {Object.defineProperty ( a, b, Object.getOwnPropertyDescriptor (c, b))})} retornar a} função h (a, b, c) {retornar b em um? Object.defineProperty (a, b, {valor: c, enumerável:! 0, configurável:! 0, gravável:! 0}): a [b] = c, a} função i () {var a = argument.length> 0 && void 0! == argumentos [0]? Argumentos [0]: {}, b = novo v, c = b.tween (a); retorna c.tweenable = b, c} cd (b, "e", função ( ) {return q}), cd (b, "c", função () {return s}), cd (b, "b", função () {return t}), cd (b, "a", function () {return v}), cd (b, "d", função () {return i}); var j = c (1), k = "indefinido"! = tipo de janela? window: a, l = k .RequestAnimationFrame || k.webkitRequestAnimationFrame || k.oRequestAnimationFrame || k.msRequestAnimationFrame || , j), q = função (a, b, c, d, e, f, g) {var h = a <f? 0: (af) / e; para (var i em b) {var j = g [i], k = j.call? j: p [j], l = c [i]; b [i] = l + (d [i] -l) * k (h)} retorne b}, r = função (a,b) {var c = apêndice A., d = a._currentState, e = a._delay, f = a._easing, g = a._originalState, h = a._duração, i = a._step, j = a. _targetState, k = a._timestamp, l = k + e + h, m = b> l? l: b, n = h- (lm); m> = l? (i (j, c, n), a .stop (! 0)) :( a._applyFilter ("beforeTween"), m <k + e? (m = 1, h = 1, k = 1): k + = e, q (m, d, g, j, h, k, f), a._applyFilter ("afterTween"), i (d, c, n))}, s = function () {para (var a = v.now (), b = n; b;) {var c = b._next; r (b, a), b = c}}, t = função (a) {var b = argument.length> 1 && void 0! == argumentos [1]? argumentos [ 1]: "linear", c = {}, d = e (b); if ("string" === d || "função" === d) para (var f em a) c [f] = b; caso contrário, para (var g em a) c [g] = b [g] || "linear"; retorne c}, u = função (a) {if (a === n) (n = a._next )? n._previous = null: o = null; caso contrário, se (a === o) (o = a._previous)? o._next = null: n = null; else {var b = a._previous, c = a._next; b._next = c, c._previous = b} a._previous = a._next = null},v = função () {função a () {var b = argumentos.length> 0 && vazio 0! == argumentos [0]? argumentos [0]: {}, c = argumentos.length> 1 && vazio 0! == argumentos [1 ]? argumentos [1]: void 0;! function (a, b) {if (! (uma instância de b)) lança novo TypeError ("Não é possível chamar uma classe como uma função")} (this, a), this. _currentState = b, this._configured =! 1, this._filters = [], this._timestamp = null, this._next = null, this._previous = null, c && this.setConfig (c)} var b, c, e; return b = a, (c = [{key: "_ applyFilter", valor: function (a) {var b =! 0, c =! 1, d = void 0; tente {for (var e, f = this. _filters [Symbol.iterator] ();! (b = (e = f.next ()). done); b =! 0) {var g = valor e. [a]; g && g (this)}} catch ( a) {c =! 0, d = a} finalmente {tente {b || nulo == f.return || f.return ()} finalmente {if (c) lance d}}}}, {key: " interpolação ", valor: função () {var b = argumentos.length> 0 && vazio 0! == argumentos [0]? argumentos [0]: vazio 0, c = isso._attachment, d = this._configured; return! b && d || this.setConfig (b), this._pausedAtTime = null, this._timestamp = a.now (), this._start (this.get (), c), this .resume ()}}, {chave: "setConfig", valor: function () {var b = isto, c = argumentos.length> 0 && void 0! == argumentos [0]? argumentos [0]: {}, d = c. anexo, e = c.delay, f = nulo 0 === e? 0: e, h = c.duração, i = nulo 0 === h? 500: h, j = c.easing, k = c.from, l = c.promise, n = void 0 === l? Promessa: l, o = c.start, p = void 0 === o? m: o, q = c.step, r = void 0 === q? m: q, s = c.to; this._configured =! 0, this._attachment = d, this._isPlaying =! 1, this._pausedAtTime = null, this._scheduleId = null, this._delay = f, this._start = p, this._step = r, this._duration = i, this._currentState = g ({}, k || this.get ()), this._originalState = this.get (), this._targetState = g ({}, s || this.get ()); var u = this._currentState; this._targetState = g ({}, u, {}, this._targetState), este. _easing = t (u, j); var v = filtros a;for (var w in this._filters.length = 0, v) v [w] .doaplicar (this) && this._filters.push (v [w]); retornar this._applyFilter ("tweenCreated"), this._promise = novo n (função (a, c) {b._resolve = a, b._reject = c}), this._promise.catch (m), this}}, {key: "get", value: function () { return g ({}, this._currentState)}}, {key: "set", value: function (a) {this._currentState = a}}, {key: "pause", value: function () {if ( this._isPlaying) return this._pausedAtTime = a.now (), this._isPlaying =! 1, u (this), this}}, {key: "resume", value: function () {if (null === this._timestamp) retorna this.tween (); if (this._isPlaying) retorna this._promise; var b = a.now (); retorna this._pausedAtTime && (this._timestamp + = b-this._pausedAtTime, this._pausedAtTime = null), this._isPlaying =! 0, null === n? (n = this, o = this, função a () {n && (l.call (k, a, 1e3 / 60), s ())} ()) :( this._previous = o, o._próxima = isto, o = isto), isto._ promessa}}, {chave: "procurar", valor: função (b) {b = Matemática.max (b, 0); var c = a.now (); return this._timestamp + b === 0? this: (this._timestamp = cb, this._isPlaying || r (this, c), this)}}, {chave: "stop", valor: function () {var a = argumentos.length> 0 && void 0! == argumentos [0] && argumentos [0], b = este._ anexo, c = isto._currentState, d = isto._easing, e = isto._originalState, f = this._targetState; if (this._isPlaying) retorna this._isPlaying =! 1, u (this), a? (this._applyFilter ("beforeTween"), q (1, c, e, f, 1,0, d), isso. _applyFilter ("afterTween"), this._applyFilter ("afterTweenEnd"), this._resolve (c, b)): this._reject (c, b), this}}, {key: "isPlaying", value: function ( ) {return this._isPlaying}}, {key: "setScheduleFunction", valor: function (b) {a.setScheduleFunction (b)}}, {key: "descarte", valor:function () {para (var a nisto) exclua isto [a]}}]) && d (b.prototype, c), e && d (b, e), a} (); v.setScheduleFunction = function (a) { return l = a}, v.formulas = p, v.filters = {}, v.now = Date.now || function () {return + new Date}}). call (this, c (2))} , function (a, b, c) {"use strict"; cr (b), cd (b, "linear", function () {return d}), cd (b, "comfortInQuad", function () {return e}), cd (b, "facilidadeOutQuad", função () {return f}), cd (b, "facilidadeInOutQuad", função () {retorno g}), cd (b, "facilidadeInCubic", função () { return h}), cd (b, "facilidadeOutCubic", função () {return i}), cd (b, "facilidadeInOutCubic", função () {retorno j}), cd (b, "facilidadeInQuart", função () {return k}), cd (b, "facilidadeOutQuart", função () {retorno l}), cd (b, "facilidadeInOutQuart", função () {retorno m}), cd (b, "facilidadeInQuint", função ( ) {return n}), cd (b,"facilidadeOutQuint", função () {retorno o}), cd (b, "facilidadeInOutQuint", função () {retorno p}), cd (b, "facilidadeInSine", função () {retorno q}), cd (b , "facilidadeOutSine", função () {return r}), cd (b, "facilidadeInOutSine", função () {retorno s}), cd (b, "facilidadeInExpo", função () {retorno t}), cd ( b, "facilidadeOutExpo", função () {retorno u}), cd (b, "facilidadeInOutExpo", função () {retorno v}), cd (b, "facilidadeInCirc", função () {retorno w}), cd (b, "comfortOutCirc", função () {return x}), cd (b, "comfortInOutCirc", função () {return y}), cd (b, "comfortOutBounce", function () {return z}), cd (b, "facilidadeInBack", função () {retorno A}), cd (b, "facilidadeOutBack", função () {retorno B}), cd (b, "facilidadeInOutBack", função () {retorno C}) , cd (b, "elástico", função () {return D}), cd (b, "swingFromTo ", function () {return E}), cd (b," swingFrom ", function () {return F}), cd (b," swingTo ", function () {return G}), cd (b, "bounce", function () {return H}), cd (b, "bouncePast", function () {return I}), cd (b, "comfortFromTo", function () {return J}), cd (b , "comfortFrom", function () {return K}), cd (b, "comfortTo", function () {return L}); var d = função (a) {retorna a}, e = function (a) { return Math.pow (a, 2)}, f = função (a) {return- (Math.pow (a-1,2) -1)}, g = função (a) {return (a / = .5 ) <1? .5 * Math.pow (a, 2): -. 5 * ((a- = 2) * a-2)}, h = function (a) {retorna Math.pow (a, 3) }, i = função (a) {return Math.pow (a-1,3) +1}, j = função (a) {return (a / =. 5) <1? .5 * Math.pow (a , 3): 5 * (Math.pow (a-2,3) +2)}, k = função (a) {return Math.pow (a, 4)}, l = function (a) {return- (Math.pow (a-1,4) -1)}, m = função (a) {return (a / =. 5) <1? .5 * Math.pow (a, 4): -. 5 * ((a- = 2) * Math.pow (a,3) -2)}, n = função (a) {retorna Math.pow (a, 5)}, o = função (a) {retorna Math.pow (a-1,5) +1}, p = função (a) {return (a / =. 5) <1? .5 * Math.pow (a, 5) :. 5 * (Math.pow (a-2,5) +2)}, q = função ( a) {retornar 1-Math.cos (a * (Math.PI / 2))}, r = função (a) {retornar Math.sin (a * (Math.PI / 2))}, s = função ( a) {return-.5 * (Math.cos (Math.PI * a) -1)}, t = função (a) {return 0 === a? 0: Math.pow (2,10 * (a -1))}, u = função (a) {retorno 1 === a? 1: 1-Math.pow (2, -10 * a)}, v = função (a) {retorno 0 === a ? 0: 1 === a? 1: (a / =. 5) <1? .5 * Math.pow (2,10 * (a-1)) :. 5 * (2-Math.pow (2 , -10 * - a))}, w = function (a) {return- (Math.sqrt (1-a * a) -1)}, x = function (a) {return Math.sqrt (1- Math.pow (a-1,2))}, y = função (a) {return (a / =. 5) <1? -. 5 * (Math.sqrt (1-a * a) -1): .5 * (Math.sqrt (1- (a- = 2) * a) +1)}, z = função (a) {retorna a <1 / 2,75? 7,5625 * a * a: a <2 / 2,75? 7,5625 * (a- = 1,5 / 2,75) * a + 0,75: a <2,5 / 2,75? 7,5625 * (a- = 2,25 / 2,75) * a + 0,9375: 7,5625 * (a- = 2,625 / 2,75) * a + 0,984375 }A = função (a) {var b = 1.70158; retornar a * a * ((b + 1) * ab)}, B = função (a) {var b = 1.70158; return (a- = 1) * a * ((b + 1) * a + b) +1}, C = função (a) {var b = 1,70158; return (a / =. 5) <1? a * a * ((1+ (b * = 1.525)) * ab) *. 5: 0,5 * ((a- = 2) * a * ((1+ (b * = 1,525)) * a + b) +2)}, D = função (a) {return-1 * Math.pow (4, -8 * a) * Math.sin ((6 * a-1) * (2 * Math.PI) / 2) +1}, E = função (a) { var b = 1.70158; return (a / =. 5) <1? a * a * ((1+ (b * = 1.525)) * ab) *. 5: .5 * ((a- = 2) * a * ((1+ (b * = 1.525)) * a + b) +2)}, F = função (a) {var b = 1.70158; retorna a * a * ((b + 1) * ab)}, G = função (a) {var b = 1,70158; return (a- = 1) * a * ((b + 1) * a + b) +1}, H = função (a) {retorna a <1 / 2,75 ? 7,5625 * a * a: a <2 / 2,75? 7,5625 * (a- = 1,5 / 2,75) * a + 0,75: a <2,5 / 2,75? 7,5625 * (a- = 2,25 / 2,75) * a + 0,9375: 7,5625 * (a- = 2,625 / 2,75) * a + 0,984375}, I = função (a) {retorna a <1 / 2,75? 7,5625 * a * a: a <2 / 2,75? 2- (7,5625 * (a- = 1,5 / 2,75) * a + 0,75): a <2,5 / 2,75? 2- (7,5625 * (a- = 2,25 / 2,75) * a + 0,9375): 2- (7,5625 * (a- = 2,625 / 2,75) * a + .984375)},J = função (a) {return (a / =. 5) <1? .5 * Math.pow (a, 4): -. 5 * ((a- = 2) * Math.pow (a, 3) -2)}, K = função (a) {retorna Math.pow (a, 4)}, L = função (a) {retorna Math.pow (a, .25)}}, função (a, b) { var c; c = function () {retorne isso} (); tente {c = c || nova função ("retorne isso") ()} catch (a) {"objeto" == tipo de janela && (c = window) } a.exports = c}, function (a, b, c) {"use strict"; function d (a) {return parseInt (a, 16)} function e (a) {var b = a._currentState; [ b, a._originalState, a._targetState] .paraCada (B), a._tokenData = E (b)} função f (a) {var b = a._currentState, c = a._originalState, d = a._targetState, e = a._easing, f = a._tokenData; K (e, f), [b, c, d] .forEach (function (a) {return F (a, f)})} função g (a) { var b = a._currentState, c = a._originalState, d = a._targetState, e = a._easing, f = a._tokenData; [b, c, d] .forEach (function (a) {return J (a , f)}), L (e, f)} função h (a, b) {var c = Object.keys (a); if (Object.getOwnPropertySymbols) {var d = Object.getOwnPropertySymbols (a); b && (d = d.filter (função (b) {retornar Object.getOwnPropertyDescriptor (a, b) .enumerable})), c.push.apply (c, d )} retornar c} função i (a) {para (var b = 1; b <argumentos.length; b ++) {var c = nulo! = argumentos [b]? argumentos [b]: {}; b% 2? h (Object (c) ,! 0) .forEach (function (b) {j (a, b, c [b])}): Object.getOwnPropertyDescriptors? Object.defineProperties (a, Object.getOwnPropertyDescriptors (c)): h (Object (c)). forEach (function (b) {Object.defineProperty (a, b, Object.getOwnPropertyDescriptor (c, b))})})} retorna a} função j (a, b, c) {return b em a? Object.defineProperty (a, b, {valor: c, enumerável:! 0, configurável:! 0, gravável:! 0}): a [b] = c, a} função k (a) {função de retorno (a) {if (Array.isArray (a)) {for (var b = 0, c = nova Matriz (a.length); b <a.length; b ++) c [b] = a [b]; return c}} (a) || function (a) {if (Symbol.iterator em Object (a) || "[object Arguments]"=== Object.prototype.toString.call (a)) retorna Array.from (a)} (a) || function () {lança novo TypeError ("Tentativa inválida de espalhar instância não iterável")} ()} função l (a, b) {para (var c = 0; c <comprimento b; c ++) {var d = b [c]; d.enumerable = d.enumerable ||! 1, d.configurable =! 0 , "valor" em d && (d.writable =! 0), Object.defineProperty (a, d.key, d)}} função m (a, b) {var c = b.get (a); if (! c) lança novo TypeError ("tentativa de obter um campo privado em não-instância"); retorna c.get? c.get.call (a): c.value} função n (a, b, c, d, e, f) {var g, h, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = função (a) {retorno ((i * a + j) * a + k) * a}, p = função (a) {retorno (3 * i * a + 2 * j) * a + k}, q = função (a) {retorno a> = 0? a: 0-a }; return i = 1- (k = 3 * b) - (j = 3 * (db) -k), l = 1- (n = 3 * c) - (m = 3 * (ec) -n) , g = a, h = função (a) {retorno 1 / (200 * a)} (f), função (a) {retorno ((l * a + m) * a + n) * a} (função ( a, b) {var c, d, e, f, g, h; para (e = a, h = 0; h <8;h ++) {if (f = o (e) -a, q (f) <b) retorna e; se (g = p (e), q (g) <1e-6) quebra; e- = f / g } if ((e = a) <(c = 0)) retorna c; if (e> (d = 1)) retorna d; for (; c <d;) {if (f = o (e), q (fa) <b) retorno e; a> f? c = e: d = e, e = 0,5 * (dc) + c} retorno e} (g, h))} cr (b); var o = {}; cr (o), cd (o, "doesApply", function () {return M}), cd (o, "tweenCreated", function () {return e}), cd (o, "beforeTween", function () {return f}), cd (o, "afterTween", function () {return g}); var p, q, r = c (0), s = / (\ d | - | \.) /,t=/([^\-0-9.unette + )/g,u=/[0-9.-)+/g,v=(p=u.source,q=/,\s* /.source,novo RegExp ("rgb \\ (". concat (p) .concat (q) .concat (p) .concat (q) .concat (p, "\\)"), "g")) , w = / ^. * \ (/, x = / # ([0-9] | [af]) {3,6} / gi, y = função (a, b) {retorna a.map (função ( a, c) {return "_". concat (b, "_"). concat (c)})}, z = função (a) {return "rgb (". concat ((b = a, 3 == = (b = b.replace (/ # /, "")). length && (b = (b = b.split (" ")) [0] + b [0] + b [1] + b [1] + b [2] + b [2]), [ d (b.substr (0,2)), d (b.substr (2,2)), d (b.substr (4,2))]). join (","), ")"); var b}, A = função (a, b, c) {var d = b.match (a), e = b.replace (a, "VAL"); return d && d.forEach (function (a) {return e = e.replace ("VAL", c (a))}), e}, B = função (a) {para (var b em a) {var c = a [b]; "string" == tipo de c && c .match (x) && (a [b] = A (x, c, z))}}, C = função (a) {var b = a.match (u) .map (Math.floor); return " ".concat (a.match (w) [0]). concat (b.join (", "),") ")}, D = função (a) {retorna a.match (u)}, E = função (a) {var b, c, d = {}; para (var e em a) {var f = a [e]; "string" == tipo de f && (d [e] = {formatString: (b = f, c = nulo 0, c = b.match (t), c? (1 === c.length || b.charAt (0) .match (s)) && c.unshift (""): c = ["", ""] c.junção ("VAL")), chunkNames: y (D (f), e)})} retorno d}, F = função (a, b) {var c = função (c) {D (a [c]) .forEach (function (d, e) {return a [b [c] .chunkNames [e]] = + d}), exclua a [c]}; para (var d in b) c (d)}, G = função (a, b) {var c = {}; retorna b.forEach (função (b) {c [b] = a [b], exclua a [b]}), c}, H = função (a , b) {retornar b.map (função (b) {retornar a [b]})}, I = função (a, b) {retornar b.forEach (função (b) {retornar a = a.replace (" VAL ", + b.paraFixed (4))}), a}, J = função (a, b) {para (var c in b) {var d = b [c], e = d.chunkNames, f = d.formatString, g = I (f, H (G (a, e), e)); a [c] = A (v, g, C)}}, K = função (a, b) {var c = função (c) {var d = b [c] .chunkNames, e = a [c]; if ("string" == tipo de e) {var f = e.split (""), g = f [f .length-1]; d.forEach (função (b, c) {retornar a [b] = f [c] || g})} else d.forEach (função (b) {retornar a [b] = e }); delete a [c]}; for (var d in b) c (d)}, L = função (a, b) {for (var c in b) {var d = b [c] .chunkNames,e = a [d [0]]; a [c] = "string" == tipo de e? d.map (função (b) {var c = a [b]; retornar excluir a [b], c}) .join (""): e}}, M = function (a) {var b = a._currentState; return Object.keys (b) .some (function (a) {return "string" == typeof b [a ]})}, N = new ra, O = rafilters, P = função (a, b, c, d) {var e = argument.length> 4 && void 0! == argumentos [4]? Argumentos [4]: ​​0 , f = i ({}, a), g = Objeto (rb) (a, d); for (var h em N._filters.length = 0, N.set ({}), N._currentState = f, N._originalState = a, N._targetState = b, N._easing = g, O) O [h]. Aplica (N) && N._filters.push (O [h]); N._applyFilter ("tweenCreated"), N._applyFilter ("beforeTween"); var j = Object (re) (c, f, a, b, 1, e, g); retorna N._applyFilter ("afterTween"), j}, Q = function () {function a () {! function (a, b) {if (! (a instance of b)) lança new TypeError ("Não é possível chamar uma classe como uma função")} (this, a), R.set (this,{gravável:! 0, valor: []}); para (var b = argumentos.length, c = nova Matriz (b), d = 0; d <b; d ++) c [d] = argumentos [d]; c.forEach (this.add.bind (this))} var b, c, d; return b = a, (c = [{key: "add", value: function (a) {return m (this, R ) .push (a), a}}, {key: "remove", value: function (a) {var b = m (this, R) .indexOf (a); return ~ b &&m (this, R) .splice (b, 1), a}}, {chave: "vazia", ​​valor: function () {retorne this.tweenables.map (this.remove.bind (this))}}, {chave: "isPlaying", valor : function () {return m (this, R). some (function (a) {return a.isPlaying ()})}}, {tecla: "play", value: function () {return m (this, R ) .forEach (function (a) {return a.tween ()}), this}}, {key: "pause", value: function () {return m (this, R) .forEach (function (a) { return a.pause ()}), this}}, {key: "resume", value: function () {return m (this, R) .forEach (function (a) {return a.resume ()}), this}}, {key: "stop ", value: function (a) {return m (this, R) .forEach (function (b) {return b.stop (a)}), this}}, {key:" tweenables ", get: function ( ) {return k (m (this, R))}}, {key: "promises", get: function () {return m (this, R) .map (function (a) {return a._promise})} }]) && l (b.prototype, c), d && l (b, d), a} (), R = novo WeakMap, S = função (a, b, c, d, e) {var f = function (a , b, c, d) {retornar função (e) {retornar n (e, a, b, c, d, 1)}} (b, c, d, e); retornar f.displayName = a, f. x1 = b, f.y1 = c, f.x2 = d, f.y2 = e, fórmulas [a] = f}, T = função (a) {retornar excluir fórmulas [a]}; cd (b, " processTweens ", function () {return rc}), cd (b," Interpolável ", function () {return ra}), cd (b," interpolação ", function () {return rd}), cd (b, "interpolar", função () {retornar P}), cd (b, "Cena", função () {retornar Q}), cd (b, "setBezierFunction", função () {retornar S}), cd (b , "unsetBezierFunction ", function () {return T}), rafilters.token = o}])})}, {}], 2: [function (a, b, c) {var d = a (" ./ shape " ), e = a ("./ utils"), f = função (a, b) {this._pathTemplate = "M 50,50 m 0, - {raio} a {raio}, {raio} 0 1 1 0 , {2radius} a {raio}, {raio} 0 1 1 0, - {2radius} ", this.containerAspectRatio = 1, d.apply (this, argumentos)}; f.prototype = new d, f.prototype. Construtor = f, f.prototype._pathString = function (a) {var b = a.strokeWidth; a.trailWidth && a.trailWidth> a.strokeWidth && (b = a.trailWidth); var c = 50-b / 2; return e .render (this._pathTemplate, {radius: c, "2radius": 2 * c})}, f.prototype._trailString = function (a) {retorna this._pathString (a)}, b.exports = f}, {"./shape":7,"./utils":9}ι,3:[function(a,b,c){{var d = a (" ./ shape "), e = a (" ./ utils "), f = função (a, b) {this._pathTemplate = b.vertical? "M {centro}, 100 L {centro}, 0": "M 0, {centro} L 100, {centro}", d.apply (this, argumentos)}; f.prototype = new d, f .prototype.constructor = f, f.prototype._initializeSvg = função (a, b) {var c = b.vertical? "0 0" + b.strokeWidth + "100": "0 0 100" + b.strokeWidth; a .setAttribute ("viewBox", c), a.setAttribute ("preserveAspectRatio", "none")}, f.prototype._pathString = function (a) {return e.render (this._pathTemplate, {center: a.strokeWidth /2})},f.prototype._trailString=function(a){return this._pathString (a)}, b.exports = f}, {"./ shape": 7, "./ utils": 9} ], 4: [função (a, b, c) {b.exports = {Linha: a ("./ line"), Círculo: a ("./ circle"), SemiCircle: a ("./ semicírculo" ), Quadrado: a ("./ square"), Caminho: a ("./ path"), Forma: a ("./ shape"), utils: a ("./utils")}},{"./circle":2,"./line":3,"./caminho":5,"./caminho":5,"./semicircle":6,"./shape":7, ". /square":8,"./utils":9}},5:[function(a,b,c){var d = a ("shifty"), e = a ("./ utils"), f = d.Tweenable, g = {facilidadeIn: "facilidadeInCubic", facilidadeOut: "facilidadeOutCubic", facilidadeInOut: "facilidadeInOutCubic"}, h = função a (b, c) {if (! (nesta instância de a)) gera um novo erro ( "O construtor foi chamado sem nova palavra-chave"); c = e.extend ({delay: 0, duration: 800, easing: "linear", de: {} para: {}, step: function () {}}, Se a resposta ajudou de alguma forma, por favor, clique em `` Resolvi meu problema '' localizado logo abaixo desta mensagem, caso a sua dúvida não tenha sido solucionada, por favor, poste novamente. (); this.path.style.strokeDasharray = f + "" + f, this.set (0)}; h.prototype.value = function () {var a = this._getComputedDashOffset (), b = this.path.getTotalLength (), c = 1-a / b; return parseFloat (c.toFixed (6), 10)}, h.prototype.set = function (a) {this.stop (), this.path.style.strokeDashoffset = this._progressToOffset (a); var b = this._opts.step; if (e.isFunction (b)) {var c = this._easing (this._opts.easing); b (this._calculateTo (a, c ), this._opts.shape || isto, this._opts.attachment)}}, h.prototype.stop = function () {this._stopTween (), this.path.style.strokeDashoffset = this._getComputedDashOffset ()} , h.prototype.animate = função (a, b, c) {b = b || {}, função e.is (b) && (c = b, b = {}); var d = e.extend ({ }, b), g = e.extend ({}, this._opts); b = e.extend (g, b); var h = this._easing (b.easing), i = this._resolveFromAndTo (a, h, d); this.stop (), this.path.getBoundingClientRect (); var j = this._getComputedDashOffset (), k = this._progressToOffset (a), l = this; this._tweenable = new f. _tweenable.tween ({from: e.extend ({offset: j}, i.from), para: e.extend ({offset: k}, i.to), duração:b.duração, atraso: b.delay, flexibilização: h, passo: função (a) {l.path.style.strokeDashoffset = a.offset; var c = b.shape || l; b.step (a, c , b.attachment)}}). then (function (a) {e.isFunction (c) && c ()}). catch (function (a) {throw console.error ("Erro na interpolação:", a), a})}, h.prototype._getComputedDashOffset = function () {var a = window.getComputedStyle (this.path, null); retornar parseFloat (a.getPropertyValue ("golpe-traço"), 10)}, h.prototype ._progressToOffset = function (a) {var b = this.path.getTotalLength (); return ba * b}, h.prototype._resolveFromAndTo = function (a, b, c) {return c.from && c.to? {from: c.from, para: c.to}: {de: this._calculateFrom (b), para: this._calculateTo (a, b)}}, h.prototype._calculateFrom = function (a) {return d.interpolate ( this._opts.from, this._opts.to, this.value (), a)}, h.prototype._calculateTo = function (a, b) {return d.interpola (this._opts.from, this._opts.to, a, b)}, h.protótipo._para_interpretação = função () {nulo! == isto._ interpolável && (esta._ interpolável.stop (! 0), este._ interpolável = nulo)}, h.protótipo. _easing = function (a) {return g.hasOwnProperty (a)? g [a]: a}, b.exports = h}, {"./ utils": 9, shifty: 1}], 6: [function ( a, b, c) {var d = a ("./forma"), e = a ("./ círculo"), f = a ("./ utils"), g = função (a, b) { this._pathTemplate = "M 50,50 m - {raio}, 0 a {raio}, {raio} 0 1 1 {2radio}, 0", this.containerAspectRatio = 2, d.apply (this, argumentos)}; g.prototype = novo d, g.prototype.constructor = g, g.prototype._initializeSvg = função (a, b) {a.setAttribute ("viewBox", "0 0 100 50")}, g.prototype._initializeTextContainer = função (a, b, c) {a.text.style && (c.style.top = "auto", c.style.bottom = "0", a.text.alignToBottom? f.setStyle (c, "transform "," traduzir (-50%,0) "): f.setStyle (c," transformar "," converter (-50%, 50%) "))}, g.prototype._pathString = e.prototype._pathString, g.prototype._trailString = e. prototype._trailString, b.exports = g}, {"./ circle": 2, "./ shape": 7, "./ utils": 9}], 7: [function (a, b, c) { var d = a ("./ caminho"), e = a ("./ utils"), f = "O objeto é destruído", g = função a (b, c) {if (! (nesta instância de a)) throw new Error ("O construtor foi chamado sem nova palavra-chave"); if (0! == argument.length) {this._opts = e.extend ({color: "# 555", strokeWidth: 1, trailColor: 1, trailColor: null, trailWidth : nulo, preenchimento: nulo, texto: {estilo: {cor: nulo, posição: "absoluto", esquerda: "50%", superior: "50%", preenchimento: 0, margem: 0, transformação: {prefixo: ! 0, valor: "translate (-50%, -50%)"}}, autoStyleContainer:! 0, alignToBottom:! 0, valor: null, className: "progressbar-text "}, svgStyle: {display:" block ", width:" 100% "}, avisos:! 1}, c,! 0), e.isObject (c) && void 0! == c.svgStyle && ( this._opts.svgStyle = c.svgStyle), e.isObject (c) && e.isObject (c.text) && void 0! == c.text.style && (this._opts.text.style = c.text.style) ; var f, g = this._createSvgView (this._opts); if (! (f = e.isString (b)? document.querySelector (b): b)) lança novo erro ("O contêiner não existe:" b); this._container = f, this._container.appendChild (g.svg), this._opts.warnings && this._warnContainerAspectRatio (this._container), this._opts.svgStyle && e.setStyles (g.svg, this._opts.svgStyle) ), this.svg = g.svg, this.path = g.path, this.trail = g.trail, this.text = null; var h = e.extend ({attachment: void 0, shape: this}, this._opts); this._progressPath = novo d (g.path, h), e.isObject (this._opts.text) && null!== this._opts.text.value && this.setText (this._opts.text.value)}}; g.prototype.animate = function (a, b, c) {if (null === this._progressPath) lança novo Erro (f); this._progressPath.animate (a, b, c)}, g.prototype.stop = function () {if (null === this._progressPath) lança novo erro (f); void 0! = = this._progressPath && this._progressPath.stop ()}, g.prototype.pause = function () {if (null === this._progressPath) lança um novo erro (f); void 0! == this._progressPath && this._progressPath. _tweenable && this._progressPath._tweenable.pause ()}, g.prototype.resume = function () {if (null === this._progressPath) gera novo erro (f); void 0! == this._progressPath && this._progressPath._tweenable && this ._progressPath._tweenable.resume ()}, g.prototype.destroy = function () {if (null === this._progressPath) lança novo erro (f); this.stop (), this.svg.parentNode.removeChild (this.svg), isso.svg = null, this.path = null, this.trail = null, this._progressPath = null, null! == this.text && (this.text.parentNode.removeChild (this.text), this.text = null)} , g.prototype.set = function (a) {if (null === this._progressPath) lança novo erro (f); this._progressPath.set (a)}, g.prototype.value = function () {if (null === this._progressPath) lança novo erro (f); retorna nulo 0 === this._progressPath? 0: this._progressPath.value ()}, g.prototype.setText = function (a) {if ( null === this._progressPath) lança novo erro (f); null === this.text && (this.text = this._createTextContainer (this._opts, this._taintainer), this._container.appendChild (this.text) ), e.isObject (a)? (e.removeChildren (this.text), this.text.appendChild (a)): this.text.innerHTML = a}, g.prototype._createSvgView = function (a) {var b = document.createElementNS ("http://www.w3.org/2000/svg", "svg"); this._initializeSvg (b, a);var c = null; (a.trailColor || a.trailWidth) && (c = this._createTrail (a), b.appendChild (c)); var d = this._createPath (a); return b.appendChild (d ), {svg: b, caminho: d, trilha: c}}, g.protótipo._initializeSvg = função (a, b) {a.setAttribute ("viewBox", "0 0 100 100")}, g.protótipo ._createPath = function (a) {var b = this._pathString (a); return this._createPathElement (b, a)}, g.prototype._createTrail = function (a) {var b = this._trailString (a), c = e.extend ({}, a); retornar c.trailColor || (c.trailColor = "# eee"), c.trailWidth || (c.trailWidth = c.strokeWidth), c.color = c. trailColor, c.strokeWidth = c.trailWidth, c.fill = null, this._createPathElement (b, c)}, g.prototype._createPathElement = function (a, b) {var c = document.createElementNS ("http: / /www.w3.org/2000/svg","path");return c.setAttribute ("d", a), c.setAttribute ("stroke", b.color), c.setAttribute ("largura do traço", b.strokeWidth), b.fill? c.setAttribute ("preenchimento", b.fill): c.setAttribute ("preenchimento da opacidade", "0"), c}, g. prototype._createTextContainer = função (a, b) {var c = document.createElement ("div"); c.className = a.text.className; var d = a.text.style; return d && (a.text.autoStyleContainer && (b.style.posição = "relativo"), e.setStyles (c, d), d.color || (c.style.color = a.color)), this._initializeTextContainer (a, b, c), c}, g.prototype._initializeTextContainer = function (a, b, c) {}, g.prototype._pathString = function (a) {throw new Error ("Substitua essa função para cada barra de progresso")}, g.prototype ._trailString = function (a) {throw new Error ("Substitua esta função para cada barra de progresso")}, g.prototype._warnContainerAspectRatio = function (a) {if (this.containerAspectRatio) {var b = window.getComputedStyle (a, null), c = parseFloat (b.getPropertyValue ("width"), 10), d = parseFloat (b.getPropertyValue ("height"), 10); e.floatEquals (this.containerAspectRatio, c / d ) || (console.warn ("Proporção incorreta do contêiner", "#" + a.id, "detectado:", b.getPropertyValue ("width") + "(width)", "/", b. getPropertyValue ("height") + "(height)", "=", c / d), console.warn ("A proporção da imagem deve ser", this.containerAspectRatio))}}, b.exports = g}, { "./path":5,"./utils":9}},8:[function(a,b,c){var d = a (" ./ shape "), e = a (" ./ utils "), f = function (a, b) {this._pathTemplate =" M 0, {halfOfStrokeWidth} L {width}, {halfOfStrokeWidth} L {width}, {width} L {halfOfStrokeWidth}, {width} L {halfOfStrokeWidth }, {strokeWidth} ", this._trailTemplate ="M {startMargin}, {halfOfStrokeWidth} L {width}, {halfOfStrokeWidth} L {width}, {width} L {halfOfStrokeWidth}, {width} L {halfOfStrokeWidth}, {halfOfStrokeWidth} ", d.apply (este argumento) }; f.prototype = new d, f.prototype.constructor = f, f.prototype._pathString = function (a) {var b = 100-a.strokeWidth / 2; return e.render (this._pathTemplate, {width : b, strokeWidth: a.strokeWidth, halfOfStrokeWidth: a.strokeWidth / 2})}, f.prototype._trailString = function (a) {var b = 100-a.strokeWidth / 2; return e.render (this._trailTemplate , {width: b, strokeWidth: a.strokeWidth, halfOfStrokeWidth: a.strokeWidth / 2, startMargin: a.strokeWidth / 2-a.trailWidth / 2})}, b.exports = f}, {"./ shape" : 7, "./ utils": 9}], 9: [função (a, b, c) {função d (a, b, c) {a = a || {}, b = b || {} , c = c ||! 1; para (var e b) se (b.hasOwnProperty (e)) {var f = a [e], g = b [e]; c && l (f) && l (g)? a [e] = d (f, g, c):a [e] = g} retorna a} função e (a, b) {var c = a; para (var d em b) if (b.hasOwnProperty (d)) {var e = b [d], f = "\\ {" + d + "\\}", g = new RegExp (f, "g"); c = c. substituir (g, e)} retornar c} função f (a, b, c) {para (var d = a.style, e = 0; e <comprimento de p; ++ e) {d [p [e] + h (b)] = c} d [b] = c} função g (a, b) {m (b, função (b, c) {null! == b && void 0! == b && (l (b) &&! 0 === b.prefix? f (a, c, b.value): a.style [c] = b)})} função h (a) {return a.charAt (0) .toUpperCase () + a.slice (1)} função i (a) {return "string" == typeof a || uma instância da String} função j (a) {return "function" == tipo de a} função k (a) {return "[object Array]" === Object.prototype.toString.call (a)} função l (a) {return! k (a) && ("objeto" == tipo de a && !! a)} função m (a, b) {for (var c em a) if (a.hasOwnProperty (c)) { var d = a [c]; b (d, c)}} função n (a, b) {retornar Math.abs (ab) <q} função o (a) {for (; a.firstChild;) a.removeChild (a.firstChild)} var p = "Webkit Moz O ms" .split (""), q = .001; b.exports = {ext: d, render: e, setStyle: f, setStyles: g, capitalizar: h, isString: i, isFunction: j, isObject: l, forEachObject: m, floatEquals: n, removeChildren: o}}, {}] }, {}, [4]) (4)});
// # sourceMappingURL = progressbar.min.js.map